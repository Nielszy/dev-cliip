---
apiVersion: v1
kind: ConfigMap
metadata:
  name: create-gnmic-target-file
  namespace: network-monitoring
data:
  gnmic-targets-configMap.yaml.j2: |
    ---
    apiVersion: v1
    kind: ConfigMap
    metadata:
      name: gnmic-targets
      namespace: network-monitoring
    data:
      targets.gnmic.yaml: |
        ---
    {% for device in devices %}
    {%     if device.platform.name == "Arista EOS" and 'gnmic' in device.monitored_with %}
        {{ device.name }}:
          address: {{ device.primary_ipv4 }}:6030
    {%     elif 'gnmic' in device.monitored_with %}
        {{ device.name }}:
          address: {{ device.primary_ipv4 }}:9339
    {%     endif %}
    {% endfor %}


  create_gnmic_target_file.py: |
    import os
    import sys
    import logging
    from typing import List, Dict, Any
    import requests
    import urllib3
    from jinja2 import Environment, FileSystemLoader
    import yaml
    import base64

    # Logging configuration
    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
    logger = logging.getLogger(__name__)

    class gNMIcTargetFileCreator:
        def __init__(self):
            # Configuration constants
            self.GITHUB_URL = "https://api.github.com"
            self.TARGET_FILE_TEMPLATE_PATH = "/opt/gnmic-targets-configMap.yaml.j2"

            # API paths
            self.NETBOX_DEVICE_PATH = "/api/dcim/devices/"
            self.GITHUB_GNMIC_FILE_PATH = "/dev-cliip/flux/applications/base/network-monitoring/gnmic/gnmic-config-files/gnmic-targets-configMap.yaml"
            self.GITHUB_REPO_FILE_PATH = "flux/applications/base/network-monitoring/gnmic/gnmic-config-files/gnmic-targets-configMap.yaml"

            # Load environment variables
            self.GITHUB_REPO_NAME = os.getenv("GITHUB_REPO_NAME")
            self.NETBOX_URL = os.getenv("NETBOX_URL")
            self.GITHUB_PAT = os.getenv("GITHUB_PAT")
            self.GITHUB_REPO_OWNER = os.getenv("GITHUB_REPO_OWNER")
            self.GITHUB_REPO_BRANCH= os.getenv("GITHUB_REPO_BRANCH")
            self.NETBOX_API_TOKEN = os.getenv("NETBOX_API_TOKEN")

            # Disable SSL warnings for NetBox requests
            urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

        def _fetch_netbox_devices(self) -> List[Dict[str, Any]]:
            """
            Fetch devices from NetBox.

            Returns:
                List[Dict[str, Any]]: Filtered list of VMs
            """
            try:
                response = requests.get(
                    f"{self.NETBOX_URL}{self.NETBOX_DEVICE_PATH}",
                    params={"limit": "500"},
                    timeout=5,
                    verify=False,
                    headers={
                        "Accept": "application/json",
                        "Authorization": f"Token {self.NETBOX_API_TOKEN}",
                    },
                )
                response.raise_for_status()

                filtered_devices = []
                for item in response.json()["results"]:
                    # Validate primary IP is present
                    if item["primary_ip4"] is None:
                        print(f"{item['name']} is missing primary IPv4 address in NetBox.")
                        continue

                    # Transform and clean device data
                    device = {
                        "name": item["name"],
                        "primary_ipv4": item["primary_ip4"]["address"].split("/")[0], # Remove subnet mask
                        "monitored_with": item["custom_fields"]["monitored_with"],
                        "platform": item["platform"],
                    }
                    filtered_devices.append(device)

                # print(json.dumps(filtered_devices))
                return filtered_devices
            except requests.RequestException as e:
                logger.error(f"Error fetching devices from NetBox: {e}")
                sys.exit(1)

        def _render_templated_target_file(self) -> str:
            """
            Render a Jinja2 template using data from _fetch_netbox_devices() method.

            Returns:
                str: Rendered YAML content as a string
            """
            try:
                # Get data from the _fetch_netbox_devices function
                filtered_devices = self._fetch_netbox_devices()

                # Wrap the list in a dictionary:
                template_data = {"devices": filtered_devices}

                # Create Jinja2 environment
                env = Environment(loader=FileSystemLoader("./"), trim_blocks=True, lstrip_blocks=True )

                # Load the template
                template = env.get_template(self.TARGET_FILE_TEMPLATE_PATH)

                # Render the template with data
                rendered_content = template.render(**template_data)

                # Validate that the rendered content is valid YAML
                try:
                    yaml.safe_load(rendered_content)
                except yaml.YAMLError as e:
                    raise ValueError(f"Rendered template is not valid YAML: {e}")
                # print("Rendered YAML:")
                # print(rendered_content)
                return rendered_content

            except FileNotFoundError:
                raise FileNotFoundError(f"Template file '{self.TARGET_FILE_TEMPLATE_PATH}' not found in 'templates' directory")
            except Exception as e:
                raise RuntimeError(f"Error rendering template: {e}")

        def _upload_to_github(self, commit_message: str = "Update gNMIc targets with current NetBox data") -> bool:
            """
            Upload YAML content to GitHub repository using PAT authentication.
            Args:
                commit_message (str): Commit message for the update
            Returns:
                bool: True if upload successful, False otherwise
            """
            try:
                # GitHub API URL for file operations
                github_url = f"{self.GITHUB_URL}/repos/{self.GITHUB_REPO_OWNER}/{self.GITHUB_REPO_NAME}/contents/{self.GITHUB_REPO_FILE_PATH}"
                yaml_content = self._render_templated_target_file()

                # Headers for GitHub API
                headers = {
                    "Authorization": f"token {self.GITHUB_PAT}",
                    "Accept": "application/vnd.github.v3+json"
                }

                # Add branch parameter to check the correct branch
                params = {
                    "ref": self.GITHUB_REPO_BRANCH
                }

                # First, check if file exists to get its SHA (required for updates)
                logger.info(f"Checking if file exists on branch '{self.GITHUB_REPO_BRANCH}': {self.GITHUB_REPO_FILE_PATH}")
                get_response = requests.get(github_url, headers=headers, params=params)

                file_sha = None
                if get_response.status_code == 200:
                    file_sha = get_response.json()["sha"]
                    logger.info(f"File exists, SHA: {file_sha}")
                elif get_response.status_code == 404:
                    logger.info("File doesn't exist, will create new file")
                else:
                    logger.error(f"Error checking file existence: {get_response.status_code} - {get_response.text}")
                    sys.exit(1)

                # Encode content to base64 (required by GitHub API)
                encoded_content = base64.b64encode(yaml_content.encode('utf-8')).decode('utf-8')

                # Prepare payload with the branch from environment variable
                payload = {
                    "message": commit_message,
                    "content": encoded_content,
                    "branch": self.GITHUB_REPO_BRANCH
                }

                # Include SHA if file exists (for updates)
                if file_sha:
                    payload["sha"] = file_sha

                # Upload/update the file
                logger.info(f"Uploading file to GitHub branch '{self.GITHUB_REPO_BRANCH}': {self.GITHUB_REPO_FILE_PATH}")
                response = requests.put(github_url, headers=headers, json=payload)

                if response.status_code in [200, 201]:
                    logger.info(f"Successfully uploaded file to GitHub: {self.GITHUB_REPO_FILE_PATH}")
                    return True
                else:
                    logger.error(f"Failed to upload file: {response.status_code} - {response.text}")
                    sys.exit(1)

            except Exception as e:
                logger.error(f"Error uploading file to GitHub: {e}")
                sys.exit(1)

    def main():
        create = gNMIcTargetFileCreator()
        create._render_templated_target_file()
        create._upload_to_github()

    if __name__ == "__main__":
        main()

